(* ml.grm
 *
 * COPYRIGHT (c) 2018, 2025 The Fellowship of SML/NJ (http://www.smlnj.org)
 * All rights reserved.
 *)

structure S = Symbol
structure F = Fixity
structure A = Ast
structure AU = AstUtil
structure EM = ErrorMsg

open Ast

(* functions to fix mismatch with new defn of type SourceLoc.region (which is no longer
   just a pair of positions *)

fun mkregion (a: int, b: int) = SourceLoc.REGION (a,b)

fun markexp (e as MarkExp _, _, _) = e  (* don't re-mark a marked exp, etc. *)
  | markexp (e,a,b) = MarkExp(e, mkregion (a,b))
fun markpat (p as MarkPat _, _, _) = p
  | markpat (p,a,b) = MarkPat(p, mkregion (a,b))
fun markdec (d as MarkDec _, _, _) = d
  | markdec (d,a,b) = MarkDec(d, mkregion (a,b))

(* ID (identifiers) is split into IDA (alphanumeric) and IDS (symbolic)
   IDA,IDS, TYVAR, etc. originally denoted raw symbols, which needed to be mapped
   to appropriate namespaces (val, tyc, str). Switched to having the lexer return
   strings rather than symbols for various classes of identifiers (IDA, IDS, AQID,
   TYVAR, etc.) allows us convert these strings into appropriate namespaced symbols
   (and paths) in the parser actions without going through raw symbols.
 *)

%%
%term
      EOF | SEMICOLON
    | IDA of string
    | IDS of string
    | TYVAR of string
    | INT of string * IntInf.int | INT0 of string * IntInf.int
    | WORD of string * IntInf.int
    | REAL of string * RealLit.t
    | STRING of string
    | CHAR of string
    | ABSTYPE | AND
    | ARROW | AS | BAR | CASE | DATATYPE | DOTDOTDOT | ELSE | END | EQUALOP
    | EQTYPE | EXCEPTION | DO | DOT | DARROW | FN | FUN | FUNCTOR | HANDLE
    | HASH | IF | IN | INCLUDE | INFIX | INFIXR | LAZY | LET | LOCAL | NONFIX | OF
    | OP | OPEN | OVERLOAD | RAISE | REC | SHARING | SIG | SIGNATURE | STRUCT
    | STRUCTURE | THEN | TYPE | VAL | WHERE | WHILE | WILD | WITH | WITHTYPE
    | ASTERISK | COLON | COLONGT | COMMA | LBRACE | LBRACKET | LPAREN | RBRACE
    | RBRACKET | RPAREN | ORELSE | ANDALSO | FUNSIG | VECTORSTART | BEGINQ
    | ENDQ of string | OBJL of string | AQID of string

%nonterm ident of string	(* includes '*' and '=' *)
       | id of string		(* includes '*' *)
       | idtyc of string
       | int of string * IntInf.int
       | op_op of unit
       | qident of (S.symbol -> symbol) -> symbol list
       | qid of (S.symbol -> symbol) -> symbol list
       | selector of symbol
       | tycon of symbol list   (* Ast.path *)
       | tlabel of (symbol * ty)
       | tlabels  of (symbol * ty) list
       | ty' of ty
       | tuple_ty of ty list
       | ty of ty
       | ty0_pc of ty list
       | match of rule list
       | rule of rule
       | elabel of (symbol * exp)
       | elabels of (symbol * exp) list
       | exp_ps of exp list
       | exp of exp
       | app_exp of exp fixitem list
       | aexp of exp
       | exp_list of exp list
       | exp_2c  of exp list
       | quote of exp list
       | ot_list of exp list
       | pat of pat
       | apat of pat fixitem
       | apat' of pat
       | plabel of (symbol * pat)
       | plabels of ((symbol * pat) list * bool)
       | pat_2c of pat list
       | pat_list of pat list
       | or_pat_list of pat list
       | vb of vb list
       | constraint of ty option
       | rvb of rvb list
       | rpat of (bool * exp) -> rvb
       | fb' of clause list
       | fb of fb list
       | apats of pat list
       | clause of clause
       | tb of tb list
       | tyvars of tyvar list
       | tyvarseq of tyvar list
       | tyvar_pc of tyvar list
       | db of db
       | dbs of db list
       | dtrepl of symbol * path
       | constrs of (symbol * ty option) list
       | constr of symbol * ty option
       | eb of eb list
       | qid_p of S.symbol list list
       | fixity of F.fixity
       | ldec of dec
       | exp_pa of  exp list
       | ldecs of dec
       | ops of symbol list
       | spec_s of spec list
       | spec of spec list
       | idents of spec list
       | strspec of (symbol * sigexp * path option) list
       | fctspec of (symbol * fsigexp) list
       | tyspec of (symbol * tyvar list * ty option) list
       | valspec of (symbol * ty) list
       | exnspec of (symbol * ty option) list
       | sharespec of spec list
       | patheqn of (S.symbol ->symbol) -> symbol list list
       | whspec of wherespec list
       | sign of sigexp
       | sigconstraint_op of sigexp sigConst
       | fsigconstraint_op of fsigexp sigConst
       | sigb of sigb list
       | fsigb of fsigb list
       | fsig of fsigexp
       | str of strexp
       | arg_fct of (strexp * bool) list
       | strdec of dec
       | strdecs of dec
       | sdec of dec
       | sdecs of dec
       | sdecs' of dec
       | strb of strb list
       | fparam of symbol option * sigexp
       | fparamList of (symbol option * sigexp) list
       | fctb of fctb list
       | fct_exp of fsigexp sigConst -> fctexp
       | interdec of dec

%verbose
%pos int
%arg (error) : pos * pos -> ErrorMsg.severity -> string -> ErrorMsg.bodyPrinter -> unit
%start interdec
%eop EOF SEMICOLON
%noshift EOF

%nonassoc WITHTYPE
%right AND
%right ARROW
%right DARROW
%left DO
%left ELSE
%left RAISE
%right HANDLE
%right ORELSE
%right ANDALSO
%right AS
%left COLON


%name ML

%keyword ABSTYPE AND AS CASE DATATYPE DOTDOTDOT ELSE END
  EQTYPE EXCEPTION  DO  DARROW  FN  FUN  FUNCTOR  HANDLE
  IF IN INCLUDE  INFIX  INFIXR  LAZY LET  LOCAL  NONFIX  OF  OP
  OPEN OVERLOAD  RAISE  REC  SHARING  SIG  SIGNATURE  STRUCT
  STRUCTURE THEN TYPE VAL WHILE WHERE WITH WITHTYPE
  ORELSE ANDALSO

%change -> VAL | -> THEN | -> ELSE | -> LPAREN | -> SEMICOLON |
        DARROW -> EQUALOP | EQUALOP -> DARROW | AND -> ANDALSO | COLON -> OF |
        SEMICOLON -> COMMA | COMMA -> SEMICOLON |
        -> IN IDA END | -> ELSE IDA

<%value IDA ("BOGUS")
%value IDS ("BOGUS")
%value TYVAR ("'BOGUS")
%value INT ("1", IntInf.fromInt 1)
%value INT0 ("0", IntInf.fromInt 0)
%value WORD ("0w0", IntInf.fromInt 0)
%value REAL ("0.0", RealLit.zero false)
%value STRING ("")
%value CHAR ("a")

%%

int	: INT		(INT)
	| INT0		(INT0)

id	: IDA		(IDA)
        | IDS           (IDS)
	| ASTERISK	("*")

idtyc   : IDA           (IDA)
        | IDS           (IDS)

ident	: IDA 		(IDA)
        | IDS           (IDS)
	| ASTERISK	("*")
	| EQUALOP	("=")

op_op	: OP		(error (OPleft, OPright) WARN "unnecessary `op'"
			       nullErrorBody)
	| 		()

qid	: IDA DOT qid		(fn kind => S.strSymbol IDA :: qid kind)
	| id			(fn kind => [kind id])

qident	: IDA DOT qident	(fn kind => S.strSymbol IDA :: qident kind)
	| ident			(fn kind => [kind ident])

selector: id			(labSymbol id)
	| INT			(S.labSymbol(IntInf.toString(#2 INT)))


  (* 	TYPES	*)

tycon   : IDA DOT tycon		(S.strSymbol IDA :: tycon)
	| idtyc			([S.tycSymbol idtyc])

tlabel	: selector COLON ty	(selector, ty )

tlabels : tlabel COMMA tlabels	(tlabel :: tlabels)
	| tlabel		([tlabel])

ty'	: TYVAR		(MarkTy (A.VarTy (A.Tyv (S.tyvSymbol TYVAR)),
				 mkregion (TYVARleft, TYVARright)))
	| LBRACE tlabels RBRACE
			(MarkTy(RecordTy tlabels, mkregion (LBRACEleft,RBRACEright)))
	| LBRACE RBRACE	(RecordTy [])
	| LPAREN ty0_pc RPAREN tycon
			(MarkTy (ConTy (tycon,ty0_pc), mkregion (tyconleft,tyconright)))
	| LPAREN ty RPAREN
			(ty)
	| ty' tycon	(MarkTy(ConTy(tycon,[ty']), mkregion (tyconleft,tyconright)))
	| tycon		(MarkTy(ConTy(tycon,[]), mkregion (tyconleft,tyconright)))

tuple_ty : ty' ASTERISK tuple_ty 	(ty' :: tuple_ty)
	 | ty' ASTERISK ty'	 	([ty'1,ty'2])

ty	: tuple_ty	(TupleTy tuple_ty)
	| ty ARROW ty	(ConTy ([AU.arrowTycon], [ty1, ty2]))
	| ty' 		(ty')

ty0_pc	: ty COMMA ty		([ty1,ty2])
	| ty COMMA ty0_pc 	(ty :: ty0_pc)


match	: rule			([rule])
	| rule BAR match	(rule :: match)

rule	: pat DARROW exp        (Rule{pat=pat, exp=markexp(exp, expleft,expright)})


  (* 	EXPRESSIONS	*)

elabel	: selector EQUALOP exp	(selector,exp)

elabels : elabel COMMA elabels	(elabel :: elabels)
	| elabel	        ([elabel])

exp_ps	: exp		        ([markexp (exp, expleft, expright)])
	| exp SEMICOLON exp_ps	(markexp (exp, expleft, expright) :: exp_ps)

exp	: exp HANDLE match	(HandleExp{expr=exp,rules=match})

        | exp ORELSE exp        (OrelseExp(markexp(exp1,exp1left,exp1right),
					   markexp(exp2,exp2left,exp2right)))
	| exp ANDALSO exp       (AndalsoExp(markexp(exp1,exp1left,exp1right),
					    markexp(exp2,exp2left,exp2right)))
	| exp COLON ty	        (ConstraintExp{expr=exp,constraint=ty})
	| app_exp	        (FlatAppExp(app_exp))
	| FN match	        (markexp(FnExp match, FNleft,matchright))
	| CASE exp OF match	(markexp(CaseExp{expr=exp, rules=match},
					 CASEleft,matchright))
	| WHILE exp DO exp	(WhileExp
                                   {test=markexp(exp1, exp1left, exp1right),
				    expr=markexp(exp2, exp2left, exp2right)})
	| IF exp THEN exp ELSE exp (IfExp{test=exp1,
				   thenCase=markexp(exp2,exp2left,exp2right),
				   elseCase=markexp(exp3,exp3left,exp3right)})
	| RAISE exp	        (markexp(markexp(RaiseExp exp, expleft,expright),
					 RAISEleft,expright))

app_exp	: aexp	        ([{item=markexp(aexp,aexpleft,aexpright),
			   region=mkregion(aexpleft,aexpright), fixity=NONE}])
	| ident		([let val (v,f) = var'n'fix ident
			    in {item=markexp(VarExp [v],identleft,identright),
				region=mkregion(identleft,identright),
				fixity=SOME f}
			    end])
	| aexp app_exp	({item=markexp(aexp,aexpleft,aexpright),
			  region=mkregion(aexpleft,aexpright), fixity=NONE}
                            :: app_exp)
	| ident app_exp (let val (v,f) = var'n'fix ident
			  in {item=markexp(VarExp [v],identleft,identright),
			      region=mkregion(identleft,identright),
				fixity=SOME f} :: app_exp
			 end)

 aexp	: OP ident		(VarExp [S.toVal ident])
	| OP IDA DOT qident	(VarExp (S.strSymbol IDA :: qident S.toVal))
	| IDA DOT qident	(VarExp (S.strSymbol IDA :: qident S.toVal))
	| int			(IntExp int)
	| WORD			(WordExp WORD)
	| REAL			(RealExp REAL)
	| STRING		(StringExp STRING)
	| CHAR 		        (CharExp CHAR)
	| HASH selector		(markexp(SelectorExp selector,
						   HASHleft, selectorright))
	| LBRACE elabels RBRACE	(markexp(RecordExp elabels,
					 LBRACEleft,RBRACEright))
	| LBRACE RBRACE		(RecordExp nil)
	| LPAREN RPAREN		(AU.unitExp)
	| LPAREN exp_ps RPAREN	(SeqExp exp_ps)
	| LPAREN exp_2c RPAREN	(TupleExp exp_2c)
	| LBRACKET exp_list RBRACKET     (ListExp exp_list)
	| LBRACKET RBRACKET	(ListExp nil)
        | VECTORSTART exp_list RBRACKET (VectorExp exp_list)
        | VECTORSTART RBRACKET  (VectorExp nil)
	| LET ldecs IN exp_ps END
				(markexp (LetExp{dec=markdec(ldecs, ldecsleft,ldecsright),
						 expr=SeqExp exp_ps},
					  LETleft,ENDright))
        | AQID                  (VarExp ([S.valSymbol AQID]))
        | quote                 (ListExp quote)

quote   : BEGINQ ENDQ           ([AU.quoteExp ENDQ])
        | BEGINQ ot_list ENDQ   (ot_list @ [quoteExp ENDQ])

ot_list : OBJL aexp             ([AU.quoteExp OBJL, AU.antiquoteExp aexp])
        | OBJL aexp ot_list     (AU.quoteExp OBJL :: AU.antiquoteExp aexp :: ot_list)

exp_2c	: exp COMMA exp_2c	(exp :: exp_2c)
	| exp COMMA exp		([exp1, exp2])

exp_list : exp			([exp])
	 | exp COMMA exp_list	(exp :: exp_list)

pat	: id AS pat		(markpat (LayeredPat {variable = S.toVal id, main = pat}, idleft, patright))
	| pat COLON ty		(markpat (ConstraintPat {pattern = pat, constraint = ty}, patleft, tyright))
	| apats			(markpat (FlatAppPat apats, apatsleft, apatsright))

apat	: apat'		        (markpat (apat', apat'left, apat'right))
	| LPAREN pat RPAREN	(markpat (pat, mkregion (LPARENleft, RPARENright)))
	| id			(markpat (VarPat [S.toVal id], idleft, idright)))
	| LPAREN RPAREN		(markpat (AU.unitPat, LPARENleft, RPARENright))
	| LPAREN pat COMMA  pat_list RPAREN
  				(markpat (TuplePat(pat :: pat_list), LPARENleft, RPARENright))
	| LPAREN pat BAR or_pat_list RPAREN
				(markpat (OrPat(pat :: or_pat_list), LPARENleft, RPARENright))

(* FIXME: should be "OP id", but that breaks smlnj/init/built-in.sml *)
apat'	: OP ident		(VarPat [S.toVal ident])
	| OP IDA DOT qid	(VarPat (S.strSymbol IDA :: qid S.toVal))
	| IDA DOT qid		(VarPat (S.strSymbol IDA :: qid S.toVal))
	| int			(IntPat int)
	| WORD			(WordPat WORD)
	| STRING		(StringPat STRING)
        | CHAR 			(CharPat CHAR)
	| WILD			(WildPat)
	| LBRACKET RBRACKET	(ListPat nil)
	| LBRACKET pat_list
		RBRACKET	(ListPat pat_list)
        | VECTORSTART RBRACKET  (VectorPat nil)
	| VECTORSTART pat_list
		RBRACKET	(VectorPat pat_list)
	| LBRACE RBRACE		(unitPat)
	| LBRACE plabels RBRACE (let val (d,f) = plabels
			          in RecordPat{def=d,flexibility=f}
                                 end)

plabel	: selector EQUALOP pat	((selector, pat))
	| id			(labSymbol id, VarPat [S.toVal id])
	| id AS pat		(labSymbol id,
				 LayeredPat{variable = S.toVal id,
					    main = pat})
	| id COLON ty		(labSymbol id,
				 ConstraintPat {pattern=VarPat [S.toVal id],
					        constraint=ty})
	| id COLON ty AS pat	(labSymbol id,
				 LayeredPat {variable = S.toVal id,
					     main = ConstraintPat {pattern = pat, constraint = ty}})

plabels : plabel COMMA plabels	(let val (a,(b,fx))=(plabel, plabels)
				 in (a::b, fx) end)
	| plabel		([plabel],false)
	| DOTDOTDOT		(nil, true)

pat_list: pat			([pat])
	| pat COMMA pat_list	(pat :: pat_list)

or_pat_list : pat			([pat])
	    | pat BAR or_pat_list	(pat :: or_pat_list)

vb	: vb AND vb		(vb1 @ vb2)
	| LAZY pat EQUALOP exp	([MarkVb(Vb{exp=exp, pat=pat, lazyp=true},
	                                 mkregion (patleft,expright))])
	| pat EQUALOP exp	([MarkVb(Vb{exp=exp, pat=pat, lazyp=false},
	                                 mkregion (patleft,expright))])

constraint :	 		(NONE)
	   | COLON ty	 	(SOME ty)

rvb	: rvb AND rvb		(rvb1 @ rvb2)
	| rpat EQUALOP exp	([MarkRvb(rpat (false, exp), mkregion (rpatleft, expright))])
	| LAZY rpat EQUALOP exp	([MarkRvb(rpat (true, exp), mkregion (LAZYleft, expright))])

rpat	: LPAREN rpat RPAREN	(rpat)
	| id constraint		(fn (lazy, exp) => let
				  val (v,f) = var'n'fix id
	                	  in
				    Rvb{
				        var = v, fixity = SOME(f, mkregion (idleft, idright)),
				        resultty = constraint,
				        exp = exp, lazyp = lazy
				      }
				  end)
	| OP id constraint	(fn (lazy, exp) => Rvb{
				    var = S.toVal id, fixity = NONE,
				    resultty = constraint,
				    exp = exp, lazyp = lazy
				  })


fb'	: clause		([clause])
	| clause BAR fb'	(clause :: fb')

fb	: fb'			([MarkFb(Fb(fb',false), mkregion (fb'left,fb'right))])
	| LAZY fb'		([MarkFb(Fb(fb',true), mkregion (fb'left,fb'right))])
	| fb' AND fb		(MarkFb(Fb(fb',false), mkregion (fb'left,fb'right)) :: fb)
	| LAZY fb' AND fb	(MarkFb(Fb(fb',true), mkregion (fb'left,fb'right)) :: fb)

apats	: apat			([apat])
	| apat apats		(apat :: apats)

clause	: apats constraint EQUALOP exp
		(Clause{pats=apats,
			resultty=constraint,
			exp=markexp(exp,expleft,expright)})


tb	: tyvars idtyc EQUALOP ty ([MarkTb(
				   Tb {tyvars = tyvars, tyc = S.tycSymbol idtyc, def = ty},
				   mkregion (tyvarsleft,tyright))])
	| tb AND tb		(tb1 @ tb2)

tyvars	: TYVAR			([A.MarkTyv (A.Tyv (S.tyvSymbol TYVAR),
					     mkregion (TYVARleft, TYVARright))])
	| LPAREN tyvar_pc RPAREN  (tyvar_pc)
	|			  (nil)

tyvarseq: TYVAR			([A.MarkTyv (A.Tyv (S.tyvSymbol TYVAR),
					     mkregion (TYVARleft, TYVARright))])
	| LPAREN tyvar_pc RPAREN  (tyvar_pc)

tyvar_pc: TYVAR                 ([A.MarkTyv (A.Tyv(S.tyvSymbol TYVAR), mkregion (TYVARleft, TYVARright))])
	| TYVAR COMMA tyvar_pc  (A.MarkTyv (A.Tyv(S.tyvSymbol TYVAR), mkregion (TYVARleft, TYVARright))
				 :: tyvar_pc)

dtrepl  : idtyc EQUALOP DATATYPE tycon      ((S.tycSymbol idtyc, tycon))

dbs     : db                             ([db])
        | db AND dbs                     (db :: dbs)

db	: idtyc EQUALOP constrs	         (Db {tyc = S.tycSymbol idtyc,
					      tyvars = nil,
					      rhs = constrs,
					      lazyp = false})
	| tyvarseq idtyc EQUALOP constrs (Db {tyc = S.tycSymbol idtyc,
					      tyvars = tyvarseq,
					      rhs = constrs,
					      lazyp = false})
        | LAZY tyvars idtyc EQUALOP constrs (Db {tyc = S.tycSymbol idtyc,
						 tyvars = tyvars,
						 rhs = constrs,
						 lazyp = true})

constrs : constr		([constr])
	| constr BAR constrs	(constr :: constrs)

constr	: op_op id		(S.toVal id, NONE)
	| op_op id OF ty	(S.toVal id, SOME ty)

eb	: op_op id		([EbGen{exn=(S.toVal id),etype=NONE}])
	| op_op id OF ty	([EbGen{exn=(S.toVal id),etype=SOME ty}])
	| op_op id EQUALOP qid	([EbDef{exn=S.toVal id, edef=qid S.toVal}])
	| eb AND eb		(eb1 @ eb2)

qid_p	: qid			([qid S.strSymbol])
	| qid qid_p		(qid S.strSymbol :: qid_p)

fixity	: INFIX			(F.infixleft 0)
	| INFIX int		(F.infixleft (AU.checkFix(#2 int, mkregion(intleft, intright))))
	| INFIXR		(F.infixright 0)
	| INFIXR int		(F.infixright (AU.checkFix(#2 int, mkregion(intleft, intright))))
	| NONFIX		(F.NONfix)

ldec	: VAL vb		(ValDec(vb,nil))
        | VAL tyvarseq vb	(ValDec(vb,tyvarseq))
	| VAL REC rvb		(ValrecDec(rvb,nil))
	| VAL tyvarseq REC rvb	(ValrecDec(rvb,tyvarseq))
	| FUN fb		(FunDec(fb,nil))
	| FUN tyvarseq fb	(FunDec(fb,tyvarseq))
	| TYPE tb		(TypeDec tb)
        | DATATYPE dtrepl       (DataReplDec dtrepl)
	| DATATYPE dbs		(DatatypeDec{datatycs=dbs,withtycs=[]})
 	| DATATYPE dbs WITHTYPE tb  (DatatypeDec{datatycs=dbs,withtycs=tb})
	| ABSTYPE dbs WITH ldecs END (AbstypeDec{abstycs=dbs,withtycs=[],
						 body=ldecs})
	| ABSTYPE dbs WITHTYPE tb WITH ldecs END  (AbstypeDec{abstycs=dbs,
							      withtycs=tb,
							      body=ldecs})
	| EXCEPTION eb		(ExceptionDec eb)
	| OPEN qid_p		(OpenDec qid_p)
	| fixity ops		(FixDec{fixity=fixity, ops=ops})
	| OVERLOAD id AS exp_pa (OvldDec(S.toVal id, exp_pa))
	| OVERLOAD id COLON ty AS exp_pa
				(OvldDec(S.toVal id, exp_pa))

exp_pa	: exp			([exp])
	| exp AND exp_pa	(exp :: exp_pa)

ldecs	: 			(SeqDec nil)
	| ldec ldecs  		(AU.makeSEQdec
				 (markdec(ldec,ldecleft,ldecright), ldecs))
	| SEMICOLON ldecs	(ldecs)
	| LOCAL ldecs IN ldecs END ldecs
 		(AU.makeSEQdec
 		   (markdec(LocalDec(markdec(ldecs1,ldecs1left,ldecs1right),
				     markdec(ldecs2,ldecs2left,ldecs2right)),
			    LOCALleft,ENDright),
 	            ldecs3))

ops	: ident			([fixSymbol ident])
	| ident ops 		(fixSymbol ident :: ops)

spec_s	: 			([])
	| spec spec_s		(spec @ spec_s)
	| SEMICOLON spec_s	(spec_s)

spec	: STRUCTURE strspec	([StrSpec strspec])
        | FUNCTOR fctspec	([FctSpec fctspec])
	| DATATYPE dtrepl       ([DataReplSpec dtrepl])
	| DATATYPE dbs		([DataSpec{datatycs=dbs,withtycs=nil}])
	| DATATYPE dbs WITHTYPE tb ([DataSpec{datatycs=dbs,withtycs=tb}])
	| TYPE tyspec		([TycSpec(tyspec,false)])
	| EQTYPE tyspec		([TycSpec(tyspec,true)])
	| VAL valspec		([ValSpec valspec])
	| EXCEPTION exnspec	([ExceSpec exnspec])
	| SHARING sharespec	(sharespec)
	| INCLUDE sign		([IncludeSpec sign])
	| INCLUDE IDA idents	(IncludeSpec(VarSig(S.sigSymbol IDA)) :: idents)

idents	: IDA			([IncludeSpec (VarSig (S.sigSymbol IDA))])
	| IDA idents		(IncludeSpec (VarSig (S.sigSymbol IDA)) :: idents)

strspec	: strspec AND strspec	(strspec1 @ strspec2)
	| IDA COLON sign	([(S.strSymbol IDA, sign, NONE)])
	| IDA COLON sign EQUALOP qid
				([(S.strSymbol IDA, sign, SOME(qid S.strSymbol))])

fctspec	: fctspec AND fctspec	(fctspec1 @ fctspec2)
	| IDA fsig		([(S.fctSymbol IDA, fsig)])

tyspec	: tyspec AND tyspec	(tyspec1 @ tyspec2)
	| tyvars idtyc		([(S.tycSymbol idtyc,tyvars,NONE)])
        | tyvars idtyc EQUALOP ty  ([(S.tycSymbol idtyc,tyvars,SOME ty)])

valspec	: valspec AND valspec	(valspec1 @ valspec2)
	| op_op ident COLON ty  ([(S.toVal ident,ty)])


exnspec : exnspec AND exnspec	(exnspec1 @ exnspec2)
	| id			([(S.toVal id, NONE)])
	| id OF ty		([(S.toVal id, <SOME ty)])

sharespec: sharespec AND sharespec	(sharespec1 @ sharespec2)
	 | TYPE patheqn	([MarkSpec (ShareTycSpec (patheqn S.tycSymbol),
				    mkregion (patheqnleft, patheqnright))])
	 | patheqn	([MarkSpec (ShareStrSpec (patheqn S.strSymbol),
				    mkregion (patheqnleft,patheqnright))])

patheqn : qid EQUALOP qid	(fn kind => [qid1 kind, qid2 kind])
        | qid EQUALOP patheqn	(fn kind => qid kind :: patheqn kind)

whspec  : whspec AND whspec     (whspec1 @ whspec2)
        | TYPE tyvars qid EQUALOP ty
				([WhType(qid S.tycSymbol, tyvars, ty)])
        | qid EQUALOP qid	([WhStruct(qid1 S.strSymbol, qid2 S.strSymbol)])

sign	: IDA			(MarkSig(VarSig (S.sigSymbol IDA),
				         mkregion (IDAleft,IDAright)))
	| SIG spec_s END	(MarkSig(BaseSig(spec_s), mkregion (spec_sleft,spec_sright)))
        | sign WHERE whspec     (MarkSig(AugSig(sign,whspec),mkregion (signleft,whspecright)))

sigconstraint_op :		(NoSig)
	| COLON sign		(Transparent(sign))
 	| COLONGT sign		(Opaque(sign))

fsigconstraint_op :		(NoSig)
	| COLON IDA		(Transparent (VarFsig (S.fsigSymbol IDA)))
 	| COLONGT IDA		(Opaque (VarFsig (S.fsigSymbol IDA)))

sigb	: sigb AND sigb		(sigb1 @ sigb2)
	| IDA EQUALOP sign	([Sigb{name=S.sigSymbol IDA, def=sign}])

fsigb	: fsigb AND fsigb	(fsigb1 @ fsigb2)
	| IDA fparamList EQUALOP sign
		([Fsigb {name = S.fsigSymbol IDA,
			 def=BaseFsig{param=fparamList,result=sign}}])

fsig	: COLON IDA	        (VarFsig (S.fsigSymbol! IDA))
	| fparamList COLON sign	(BaseFsig{param=fparamList,result=sign})

str	: qid	((MarkStr(VarStr(qid S.strSymbol), mkregion (qidleft,qidright))))
	| STRUCT strdecs END
		(MarkStr(BaseStr strdecs, mkregion (STRUCTleft,ENDright)))
	| qid arg_fct
		(MarkStr(AppStr(qid S.fctSymbol, arg_fct),
			 mkregion (qidleft,arg_fctright)))
	| LET strdecs IN str END
		(MarkStr(LetStr(strdecs, str), mkregion (LETleft,ENDright)))
        | str COLON sign
	        (MarkStr(ConstrainedStr(str,Transparent sign),
		         mkregion (strleft,signright)))
        | str COLONGT sign
	        (MarkStr(ConstrainedStr(str,Opaque sign),
		         mkregion (strleft,signright)))

arg_fct : LPAREN strdecs RPAREN arg_fct  ((MarkStr(BaseStr strdecs,
						  mkregion (strdecsleft,strdecsright)),
					  false) :: arg_fct)
	| LPAREN str RPAREN arg_fct	 ((str, true) :: arg_fct)
	| LPAREN str RPAREN 		 ([(str, true)])
	| LPAREN strdecs RPAREN 	 ([(MarkStr(BaseStr strdecs,
						   mkregion (strdecsleft,strdecsright)),
					   false)])

strdecs	: strdec strdecs	(AU.makeSEQdec (markdec(strdec,strdecleft,strdecright),
					     strdecs))
	| SEMICOLON strdecs	(strdecs)
	|			(SeqDec[])

sdecs	: sdec sdecs		(AU.makeSEQdec (markdec(sdec,sdecleft,sdecright),
					     sdecs))
	| SEMICOLON sdecs	(sdecs)
	|			(SeqDec[])

sdecs'	: sdec sdecs'		(AU.makeSEQdec (markdec(sdec,sdecleft,sdecright),
					     sdecs'))
	| sdec			(markdec(sdec, sdecleft,sdecright))

strdec	: STRUCTURE strb	(StrDec strb)
	| FUNCTOR fctb		(FctDec fctb)
	| LOCAL strdecs IN strdecs END
		                (LocalDec(markdec(strdecs1,
						  strdecs1left,strdecs1right),
  					  markdec(strdecs2,strdecs2left,strdecs2right)))
	| ldec			(markdec(ldec,ldecleft,ldecright))

sdec	: STRUCTURE strb	(StrDec strb)
	| SIGNATURE sigb	(SigDec sigb)
	| FUNSIG fsigb		(FsigDec fsigb)
	| FUNCTOR fctb		(FctDec fctb)
	| LOCAL sdecs IN sdecs END
		                (LocalDec(markdec(sdecs1,
						  sdecs1left,sdecs1right),
					  markdec(sdecs2,sdecs2left,sdecs2right)))
	| ldec			(markdec(ldec,ldecleft,ldecright))

strb	: IDA sigconstraint_op EQUALOP str
	                        ([MarkStrb(Strb{name = S.strSymbol IDA, def = str,
						constraint=sigconstraint_op},
					   mkregion (IDAleft,strright))])
	| strb AND strb		(strb1 @ strb2)

fparam	: IDA COLON sign	((SOME(S.strSymbol IDA),sign))
	| spec_s		((NONE,MarkSig(BaseSig(spec_s),
					       mkregion (spec_sleft,spec_sright))))

fparamList
	: LPAREN fparam	RPAREN			([fparam])
	| LPAREN fparam RPAREN fparamList	(fparam :: fparamList)

fctb	: IDA fparamList sigconstraint_op EQUALOP str
		([MarkFctb(Fctb {name = S.fctSymbol IDA,
                                 def = BaseFct{params=fparamList, body=str,
				              constraint=sigconstraint_op}},
			   mkregion (IDAleft,strright))])
	| IDA fsigconstraint_op EQUALOP fct_exp
		([MarkFctb(Fctb {name = S.fctSymbol IDA,
				 def=fct_exp (fsigconstraint_op)},
			   mkregion (IDAleft,fct_expright))])
	| fctb AND fctb	   (fctb1 @ fctb2)

fct_exp: qid	(fn constraint => VarFct(qid S.fctSymbol, constraint))
       | qid arg_fct
  		(fn constraint =>
		    MarkFct (AppFct (qid S.fctSymbol,arg_fct,constraint),
			     mkregion (qidleft,arg_fctright)))
       | LET strdecs IN fct_exp END
		(fn constraint =>
		   MarkFct(LetFct (strdecs, fct_exp constraint),
			   mkregion (LETleft,ENDright)))

interdec: sdecs'	(markdec (sdecs', sdecs'left, sdecs'right))

	| exp		(markdec (ValDec([Vb {exp = exp, pat = VarPat [AU.itsym], lazyp = false}], nil),
				 expleft, expright))
