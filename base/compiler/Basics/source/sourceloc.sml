(* Basics/source/sourceloc.sml *)

structure SourceLoc =
struct

(* types (charpos, location, region) for designating locations and regions within
 * a text file, or, more generally, within the contents of an input stream such as stdin.
 * Prerequisites: SourceLoc imports and depends on nothing bug the pervasives.
 * Clients: SourceLoc is used by Source, SourceMap, and ErrorMsg.
 *)

(* charpos, lineno, columnno are all 1-based, i.e, bounded by 1 <= x *)

  (* A character position (charpos) is a positive integer designating the position of
   * a character in an input stream (e.g. file).
   * A region is delimited  by the character position of the first character and that
   * of the last character of the region.
   *     a b c  ...   -- characters (starting at the beginning)
   *     1 2 3 ...    -- character positions
   * Basing the charpos at 1 for the first position is because of the similar convention
   * for the yypos variable in the lexer, so that translation from yypos to charpos is
   * an identity.
   * 
   * potential issue: the character at position charpos may be a newline!
   *   But this should not be the case for the two charpos values delimiting a region
   *   which are generated by the parser as the initial and final character positions
   *   of some nonterminal phrase.
   *
   *   Example
   *     [line 1] <nl>
   *     [line 2] abc<nl>
   *
   * Here the charpos 1 is the position of the newline terminating line 1. The initial
   * character "a" in line 2 is at charpos = 2. We assume that this does not occur in
   * the compiler because our charpos values are generated from yypos values for the
   * first or last character of a token. In other words, we assume that there are no
   * circumstances where the charpos of a newline character will occur in error messages.
   *)

  type charpos = int
    (* INVARIANT : charpos >= 1:
     * Character positions, which are 1-based. I.e. the position at the beginning of
     * a file is 1. This convention is chosen so that charpos will agree with the yypos
     * variable used in the lexer (which I assume is 1-based?).
     *
     * Note that this differs from emacs's numbering of cursor positions in a
     * buffer, which is 0-based, i.e., the cursor position at the beginning of a buffer
     * is 0. *)

  type lineno = int
     (* INVARIANT: lineno >=1. The first line in a file or instream is line 1 *)

  type columnno = int
     (* INVARIANT: columnno >=1. The first column in a line is column 1 *)

  type location = {line: lineno, column: columnno}
    (* A location gives an alternate, 2-dimensional way of designating a position in
     * the input stream.  sourcemaps are used to translate from a charpos to a location.
     *)

(* regions -- contiguous ranges of characters delimited by character positions. *)

  datatype region
    = NULLregion
    | REGION of charpos * charpos
      (* INVARIANT: REGION (lo,hi) ==> lo < hi.
       *   All REGION regions are nonempty. *)

(* following are unnecessary as long as region is available as a concrete datatype:

  val nullRegion : region = NULLregion
    (* nullRegion is a conventional default region value. It does not represent
     * a proper region, and does not have a location in the file. In particular, it
     * should not be interpretted as an empty region at the beginning of the input,
     * that is, it is not equivalent to REGION (0, 0).  In stituations where there is
     * no sensible region, use NULLregion rather than REGION (0,0).
     * Empty regions, REGION (n,n) are probably not usefule. *)

  (* isNullRegion : region -> bool *)
  fun isNullRegion (NULLregion: region) = true
    | isNullRegion _ = false
*)

(* translating regions and locations to strings *)

  (* regionToString : region -> string *)
  fun regionToString (REGION (lo, hi): region) =
        String.concat [Int.toString lo, "-", Int.toString hi]
    | regionToString NULLregion = "<<>>"  (* conventional presentation of NULLregion *)

  (* locationToString : location -> string *)
  fun locationToString ({line, column}: location) =
      String.concat [Int.toString line, ".", Int.toString column]

  (* regionUnion : region * region -> region
   * produces the minimal length region containing both region1 and region2,
   * Assuming by convention that any non-null region "contains" the NULLregion. *)
  fun regionUnion (REGION (l1, r1), REGION (l2, r2)) =
        REGION (Int.min (l1, l2), Int.max (r1, r2))
    | regionUnion (NULLregion, reg2 as REGION _) = reg2
    | regionUnion (reg1 as REGION _, NULLregion) = reg1
    | regionUnion (NULLregion, NULLregion) = NULLregion

end (* structure SourceLoc *)
